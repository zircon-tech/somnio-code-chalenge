generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
  binaryTargets   = ["native"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [citext]
}

generator erd {
  provider = "prisma-erd-generator"
  output   = "../docs/full-service-erd.svg"
}

enum Blockchain {
  SUI
  POLYGON
}

enum UserRole {
  FAN
  AUTHOR
  CREATOR

  OWNER
  AGENCY
}

enum InvitationRole {
  OWNER
  AGENCY
}

enum SpacePostType {
  SHORT
  LONG
}

enum SpacePostReplyType {
  COMMENT
  REPLY
}

enum BlockchainAssetType {
  SUI_PROFILE

  // EVM_PROFILE
}

model User {
  id String @id @default(cuid())

  email   String  @unique // comes from magic, or from seeding / whitelisting
  // optional because if we do seeding, this won't be available for us, just email.
  magicId String? @unique // comes from magic `issuer`. UNIQUE ID! https://magic.link/docs/home/faqs/dedicated-wallet#what-is-the-unique-user-id-i-should-save-to-my-database
  fvId String? @unique

  // improvement: use CiText extension for case-insensitive search, instead of using `lowercasedUsername`
  // https://github.com/prisma/prisma/issues/3851

  // main profile stuff
  isTempUsername      Boolean              @default(true)
  username            String?              @unique // set when claimed, i.e w1red_Matt
  lowercasedUsername  String?              @unique // w1red_matt
  normalizedUsername  String? // optimized for search, i.e w1redmatt
  firstName           String?
  lastName            String?
  bio                 String?
  profilePictureS3Key String?
  connectedSocials    SocialMediaAccount[]

  country String?  @db.VarChar(60)
  state   String?  @db.VarChar(50)
  city    String?  @db.VarChar(35)
  role    UserRole @default(FAN)
  // role InvitationRole?

  // users can have a new profile for each space they are in
  // note: takes into account being a FAN, CREATOR, OWNER, AGENCY all in one place.
  profiles          UserProfileInSpace[]
  stripeProfiles    StripeUserProfileInSpace[]
  subscriptions     FanSubscription[]
  freeSubscriptions FanFreeSubscription[]

  // is user is an owner or agency, and joined with an invitation token... 
  joinedWithInvitation Invitation? @relation("InvitationIsUsedBy")

  // if user is an agency...
  invitationsSentAsAgency Invitation[]

  stripeCustomerId String?

  stripeConnectAccountId         String?
  stripeConnectAccountDetectedBy String?
  stripeConnectAccountDetectedAt DateTime?
  stripeConnectAccountEnabled    Boolean   @default(false)

  sendbirdLatestSessionToken     String?
  sendbirdLatestSessionExpiresAt DateTime?

  chatRoomMembers ChatRoomMember[]

  wallets Wallet[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Wallet {
  id String @id @default(cuid())

  userId     String
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  blockchain Blockchain

  address String @unique

  assets OnChainMithAsset[]

  @@unique([userId, blockchain])
}

// OnChainMithAsset can store Profile, Membership... etc.
model OnChainMithAsset {
  id String @id @default(cuid())

  data      Json // shape of `data` depends on `assetType`.
  assetType BlockchainAssetType

  ownerWalletAddress String
  ownerWallet        Wallet @relation(fields: [ownerWalletAddress], references: [address], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model UserProfileInSpace {
  id String @id @default(cuid())

  baseUserId String
  baseUser   User   @relation(fields: [baseUserId], references: [id], onDelete: Cascade)

  // @NOTE Application-level validation: 
  //      - there can only be one OWNER per space (for now). - Has access to billing and to invite creators to the space. 
  //                                                          "Indie manager", or just not BIG corpo.
  //      - there can only be one CREATOR per space (for now). - Can make posts and such
  //      - there can only be one AGENCY per space. - Same as owner but corporate profile like Warner Music Group.
  //      - there can be as many FANs and AUTHORs as we want.
  // reason for not restricting this at db-level: reduce complexity, improve maintenance, allow for more flexibility in the future.
  role UserRole @default(FAN)

  spaceId String
  space   Space  @relation(fields: [spaceId], references: [id], onDelete: Cascade)

  notificationSettings ProfileNotificationSettings?

  // @NOTE Application-level validation:
  // only owner/author/agency of space can create posts
  authoredSpacePosts SpacePost[]
  likedSpacePosts    SpacePostLike[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  chatRoomMembers         ChatRoomMember[]
  stripeProfile           StripeUserProfileInSpace? @relation("ProfileHasStripeProfile")
  currentFreeSubscription FanFreeSubscription?

  enabled Boolean @default(true)

  // only one profile per user per space
  @@unique([baseUserId, spaceId])
}

model StripeUserProfileInSpace {
  baseUserId String
  baseUser   User   @relation(fields: [baseUserId], references: [id], onDelete: Cascade)
  email      String

  profile UserProfileInSpace @relation("ProfileHasStripeProfile", fields: [baseUserId, spaceId], references: [baseUserId, spaceId], onDelete: Cascade)

  stripeCustomerId String @unique

  spaceId String
  space   Space  @relation(fields: [spaceId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  fanSubscription FanSubscription? @relation("FanSubscriptionHasStripeProfile")

  @@unique([baseUserId, spaceId])
  @@unique([email, spaceId])
}

model ProfileNotificationSettings {
  baseUserId String
  spaceId    String

  profile UserProfileInSpace @relation(fields: [baseUserId, spaceId], references: [baseUserId, spaceId], onDelete: Cascade)

  // email
  emailNotifications      Boolean @default(false)
  dailyDigestNotification Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([baseUserId, spaceId])
}

model Invitation {
  token                  String         @id @default(uuid())
  description            String?
  domain                 String?
  freeSubscriptionLevel  Int?
  role                   InvitationRole
  stripeConnectAccountId String?

  usedAt       DateTime?
  usedByUserId String?   @unique
  usedByUser   User?     @relation("InvitationIsUsedBy", fields: [usedByUserId], references: [id], onDelete: Cascade)

  defaultBlockchain Blockchain @default(SUI)

  feeDefault    Int
  feeMembership Int?
  feeProduct    Int?

  deleted   Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  agencyId     String?
  sentByAgency User?   @relation(fields: [agencyId], references: [id], onDelete: Cascade)
}

// NOTE: This is not good, it'd be better to use a Graph DB for this.
// Another approach could be to have a table for each level, but that's also not so great.

model SpaceCategory {
  id   String @id @default(uuid())
  name String

  // Application-Level validations:
  // - Possible values: 1, 2, 3
  // - If level is 1, parentId must be null
  // - If level is 2, parentId must be a level 1 category
  // - If level is 3, parentId must be a level 2 category
  level Int @default(1) @db.SmallInt

  parentId String?
  parent   SpaceCategory? @relation("parentsubs", fields: [parentId], references: [id], onDelete: Cascade)

  subcategories SpaceCategory[] @relation("parentsubs")

  spaces Space[]
  weight Int     @default(0)

  @@index([level])
}

model Space {
  id String @id @default(cuid())

  // basic info
  name        String? @unique
  slug        String? @unique
  description String?

  // branding
  logoS3Key               String?
  iconS3Key               String?
  wallpaperS3Key          String?
  gatePageBackgroundS3Key String?

  defaultBlockchain Blockchain @default(SUI)

  categories SpaceCategory[]

  feeDefault    Int?
  feeMembership Int?
  feeProduct    Int?

  isPublished Boolean @default(false)

  isFeatured                    Boolean                         @default(false)
  featuredImageS3Key            String?
  featuredUrl                   String?
  featuredURLNewTab             Boolean?                        @default(false)
  featuredTitle                 String?
  featuredTitleJustification    SpaceFeaturedTextJustification?
  featuredTitleFontWeight       Int?
  featuredSubTitle              String?
  featuredsubTitleJustification SpaceFeaturedTextJustification?
  featuredsubTitleFontWeight    Int?
  featuredDescription           String?

  isHiddenFromExploration     Boolean @default(false)
  isFanPostingDisabledForFans Boolean @default(false)

  profiles          UserProfileInSpace[]
  stripeProfiles    StripeUserProfileInSpace[]
  subscriptions     FanSubscription[]
  freeSubscriptions FanFreeSubscription[]
  membershipTiers   MembershipTier[]           @relation("IsMembershipsOfSpace")
  themes            SpaceTheme[]

  wizardStepsData   Json[]
  wizardCurrentStep Int    @default(0)
  weight            Int    @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  membership            Membership?
  ownerSubscription     OwnerSubscription?
  freeSubscriptionLevel Int?

  posts SpacePost[]

  chatRooms       ChatRoom[]
  chatRoomMembers ChatRoomMember[]

  stripeConnectAccountId String?
}

enum SpaceThemeType {
  LIGHT
  DARK
}

model SpaceTheme {
  type SpaceThemeType

  spaceId String
  space   Space  @relation(fields: [spaceId], references: [id], onDelete: Cascade)

  backgroundColor         String
  backgroundContrastColor String
  strokeColor             String
  fillColor               String
  highlightBgColor        String
  highlightSubtleColor    String
  highlightFillColor      String
  fieldBackground         String
  fieldContrast           String
  textLinkColor           String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([spaceId, type])
}

model Membership {
  id String @id @default(cuid())

  spaceId String @unique
  space   Space  @relation(fields: [spaceId], references: [id], onDelete: Cascade)

  allPossibleBenefits Json[] // [{"name": "say hi once a day", "description": "will say hi to you once a day"}]

  tiers          MembershipTier[]
  deletedTiers   DeletedMembershipTier[]
  tiersBySpaceId MembershipTier[]        @relation("MembershipsBySpaceId")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model MembershipNativeBenefit {
  name        String @id @unique
  description String

  inMembershipTiers        MembershipTier[]
  inDeletedMembershipTiers DeletedMembershipTier[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model MembershipTier {
  id String @id @default(cuid())

  name        String
  description String?
  supply      Int // how many memberships are available for this tier. -1 for unlimited 

  artworkS3Key String?

  nativeBenefits MembershipNativeBenefit[]
  customBenefits Json[]

  membershipId String
  membership   Membership @relation(fields: [membershipId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  order Float?

  isFree              Boolean    @default(false)
  stripePriceId       String?
  spaceId             String
  membershipBySpaceId Membership @relation(fields: [spaceId], references: [spaceId], name: "MembershipsBySpaceId", map: "MembershipTier_fk_Membership_by_spaceId", onDelete: Cascade)
  space               Space      @relation(fields: [spaceId], references: [id], name: "IsMembershipsOfSpace", onDelete: Cascade)

  subscriptions        FanSubscription[] @relation("ActiveFanSubscriptionPlan")
  pendingSubscriptions FanSubscription[] @relation("PendingFanSubscriptionPlan")

  freeSubscriptions FanFreeSubscription[]

  @@unique([membershipId, name])
  @@unique([spaceId, id])
  @@unique([spaceId, name])
  @@unique([stripePriceId, spaceId])
  @@unique([stripePriceId, membershipId])
}

model DeletedMembershipTier {
  id String @id

  name        String
  description String?
  supply      Int

  artworkS3Key String?

  nativeBenefits MembershipNativeBenefit[]
  customBenefits Json[]

  membershipId String
  membership   Membership @relation(fields: [membershipId], references: [id], onDelete: Cascade)

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  order         Float?
  stripePriceId String
}

model SocialMediaAccount {
  socialId      String
  socialNetwork String // not an enum so we can add new ones in the future easily

  username       String
  url            String
  profilePicture String?

  tokens Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([socialId, socialNetwork])
  @@unique([username, socialNetwork])
  @@unique([userId, socialNetwork])
}

model SpacePost {
  id String @id @default(cuid())

  type      SpacePostType
  replyType SpacePostReplyType? // only required for replies

  title String? // title is only required for long posts
  intro String? // intro is only required for long posts

  mediaContent Json[] @default([])

  body String // html body

  authoredBySpaceProfileId String
  authoredBySpaceProfile   UserProfileInSpace @relation(fields: [authoredBySpaceProfileId], references: [id], onDelete: Cascade)

  likes     SpacePostLike[]
  likeCount Int             @default(0)

  spaceId String
  space   Space  @relation(fields: [spaceId], references: [id], onDelete: Cascade)

  inReplyTo     String?
  inReplyToPost SpacePost?  @relation("ReplyToPost", fields: [inReplyTo], references: [id], onDelete: Cascade)
  isReplyedBy   SpacePost[] @relation("ReplyToPost")
  isArchived    Boolean     @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model SpacePostLike {
  id String @id @default(cuid())

  spacePostId String
  spacePost   SpacePost @relation(fields: [spacePostId], references: [id], onDelete: Cascade)

  likedBySpaceProfileId String
  likedBySpaceProfile   UserProfileInSpace @relation(fields: [likedBySpaceProfileId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([spacePostId, likedBySpaceProfileId])
}

model FanFreeSubscription {
  baseUserId String
  baseUser   User   @relation(fields: [baseUserId], references: [id], onDelete: Cascade)

  spaceId String
  space   Space  @relation(fields: [spaceId], references: [id], onDelete: Cascade)

  subscriptionPlanId String
  subscriptionPlan   MembershipTier @relation(fields: [subscriptionPlanId, spaceId], references: [id, spaceId], onDelete: Cascade)

  userProfileInSpace UserProfileInSpace @relation(fields: [baseUserId, spaceId], references: [baseUserId, spaceId], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([baseUserId, spaceId])
}

model FanSubscription {
  stripeSubscriptionId String  @unique
  stripePriceId        String?
  stripePendingPriceId String?

  email    String
  baseUser User   @relation(fields: [email], references: [email], onDelete: Cascade)

  spaceId String
  space   Space  @relation(fields: [spaceId], references: [id], onDelete: Cascade)

  subscriptionPlan        MembershipTier? @relation("ActiveFanSubscriptionPlan", fields: [stripePriceId, spaceId], references: [stripePriceId, spaceId], onDelete: Cascade)
  pendingSubscriptionPlan MembershipTier? @relation("PendingFanSubscriptionPlan", fields: [stripePendingPriceId, spaceId], references: [stripePriceId, spaceId], onDelete: Cascade)

  stripeUserProfile StripeUserProfileInSpace @relation("FanSubscriptionHasStripeProfile", fields: [email, spaceId], references: [email, spaceId], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([email, spaceId])
}

model OwnerSubscription {
  stripeSubscriptionId String  @id
  stripePriceId        String?
  stripePendingPriceId String?

  spaceId String @unique
  space   Space  @relation(fields: [spaceId], references: [id], onDelete: Cascade)

  subscriptionPlan        OwnerSubscriptionPlan? @relation("ActiveSubscriptionPlan", fields: [stripePriceId], references: [stripePriceId], onDelete: SetNull)
  pendingSubscriptionPlan OwnerSubscriptionPlan? @relation("PendingSubscriptionPlan", fields: [stripePendingPriceId], references: [stripePriceId], onDelete: SetNull)

  createdAt DateTime @default(now())
}

model OwnerSubscriptionPlan {
  stripePriceId   String   @id
  stripeProductId String
  level           Int
  createdAt       DateTime @default(now())

  subscriptions        OwnerSubscription[] @relation("ActiveSubscriptionPlan")
  pendingSubscriptions OwnerSubscription[] @relation("PendingSubscriptionPlan")
}

model ChatRoomMember {
  baseUserId String
  chatRoomId String
  spaceId    String

  isPinned       Boolean            @default(false)
  baseUser       User               @relation(fields: [baseUserId], references: [id], onDelete: Cascade)
  chatRoom       ChatRoom           @relation(fields: [chatRoomId], references: [id], onDelete: Cascade, name: "CharRoomByChatRoomId", map: "ChatRoomMember_fk_ChatRoom_by_ChatRoomId")
  chatRoomWSpace ChatRoom           @relation(fields: [chatRoomId, spaceId], references: [id, spaceId], onDelete: Cascade, name: "CharRoomBySpaceIdChatRoomId", map: "ChatRoomMember_fk_ChatRoom_by_SpaceIdChatRoomId")
  space          Space              @relation(fields: [spaceId], references: [id], onDelete: Cascade)
  spaceProfile   UserProfileInSpace @relation(fields: [baseUserId, spaceId], references: [baseUserId, spaceId], onDelete: Cascade)

  invitationAccepted Boolean @default(false)

  createdAt DateTime @default(now())

  @@unique([baseUserId, chatRoomId])
}

model ChatRoom {
  id         String  @id @default(cuid())
  name       String
  coverS3Key String?
  type       String

  spaceId        String
  space          Space            @relation(fields: [spaceId], references: [id], onDelete: Cascade)
  membersBySpace ChatRoomMember[] @relation("CharRoomBySpaceIdChatRoomId")
  members        ChatRoomMember[] @relation("CharRoomByChatRoomId")

  createdAt DateTime @default(now())

  @@unique([id, spaceId])
  @@unique([name, spaceId])
}

enum SpaceFeaturedTextJustification {
  LEFT
  CENTER
  RIGHT
}

model FeaturedContent {
  id     String @id @default(cuid())
  weight Int    @default(0)

  isFeatured         Boolean  @default(false)
  featuredImageS3Key String?
  featuredUrl        String?
  featuredURLNewTab  Boolean? @default(false)

  featuredTitle                 String?
  featuredTitleJustification    SpaceFeaturedTextJustification?
  featuredTitleFontWeight       Int?
  featuredSubTitle              String?
  featuredsubTitleJustification SpaceFeaturedTextJustification?
  featuredsubTitleFontWeight    Int?
  featuredDescription           String?
}

model SuiAdminCap {
  id       String @id @default(cuid())
  objectId String @unique

  data Json

  createdAt DateTime @default(now())
}

model ExecutedSeeds {
  name      String   @unique
  createdAt DateTime @default(now())
}

model CronExecutions {
  period    Int       @unique
  // periodSecondsSize      Int
  startedAt DateTime
  endedAt   DateTime?
}
